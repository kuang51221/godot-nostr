<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <title>Nostr</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: Arial, Helvetica, sans-serif;
        }

        #canvas {
            /* The Godot canvas itself */
            width: 100%;
            height: 100%;
            display: block;
            /* Remove extra space below canvas */
        }

        /* Style the header */

        header {
            background-color: #666;
            padding: 1px;
            text-align: center;
            font-size: 10px;
            color: white;
        }

        /* Create two columns/boxes that floats next to each other */
        nav {
            float: left;
            width: 80%;
            /* height: 300px;  only for demonstration, should be removed */
            background: #ccc;
            padding: 5px;
            overflow-y: auto;
        }

        /* Style the list inside the menu */
        nav ul {
            list-style-type: none;
            padding: 0;
        }

        article {
            float: left;
            padding: 5px;
            width: 20%;
            background-color: #f1f1f1;
            /*height: 300px;  only for demonstration, should be removed */
            overflow-y: scroll;
        }

        /* Clear floats after the columns */
        section::after {
            content: "";
            display: table;
            clear: both;
        }

        /* Style the footer */
        footer {
            background-color: #777;
            padding: 10px;
            text-align: center;
            color: white;
        }

        /* Responsive layout - makes the two columns/boxes stack on top of each other instead of next to each other, on small screens */
        @media (max-width: 600px) {

            nav,
            article {
                width: 100%;
                height: auto;
            }
        }

        #video-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3px;
        }

        video {
            width: 95%;
            border-radius: 1px;
            padding: 3px;
            background: rgba(255, 255, 255, 0);
        }
    </style>
</head>


<body>

    <header>
        <h3>Godot-Nostr</h3>
    </header>
    <section>
        <nav>
            <canvas id="canvas" width="460" height="auto" style="border:1px solid #000000;">
            </canvas>
        </nav>
        <article style="overflow-y: scroll;">
            <div id="remoteVideos" class="video" style="border-radius: 5px;"></div>
            <div class="video" style="border-radius: 5px;">
                <video id="localVideo" autoplay muted playsinline
                    style="width: 100%;  background-color: rgb(130, 155, 119); margin-top: 1px;"></video>
            </div>
        
        </article>
    </section>
    <footer>
        <div class="section">
            <!-- <h3>1. å¸³æˆ¶è¨­ç½®</h3> -->
            <!-- <button id="generateKeys">ç”Ÿæˆæ–°å¯†é‘°</button> -->
            <div>
                <!-- <label for="privateKey">ç§é‘° (nsec):</label> -->
                <input type="text" id="privateKey" placeholder="nsec1...">
            </div>
            <div>
                <label for="publicKey">å…¬é‘° (npub):</label>
                <input type="text" id="publicKey" readonly>
            </div>

        </div>

        <div class="section">
            <h3>2. Join Room</h3>
            <div>
                <label for="subscribeTopic">Room:</label>
                <input type="text" id="subscribeTopic" placeholder="è¼¸å…¥Room">
            </div>
            <button id="subscribe">é–‹å§‹Roomè¨‚é–±</button>
            <button id="unsubscribe" disabled>åœæ­¢è¨‚é–±</button>
            <button id="broadcast">å»£æ’­</button>
            ">é–‹å§‹Roomè¨‚é–±</button>
            <h3>æ”¶åˆ°çš„æ¶ˆæ¯:</h3>
            <div id="receivedMessages"></div>
        </div>
    </footer>


    <script type="module">
        import * as nostrTools from "https://esm.sh/nostr-tools@2.15.0";

        const {
            generateSecretKey, getPublicKey, finalizeEvent, nip19, SimplePool, nip04
        } = nostrTools;
        // å…¨å±€è®Šé‡
        
        let privateKey = '';
        let publicKey = '';
        let remotePk = '';
        let subscription = null;
        let pool = new SimplePool();
        let connections = new Map()
        const iceCandidateBuffers = new Map();
        let relayConnections = []
        //const relays = ["wss://relay.damus.io", "wss://relay.snort.social", "wss://nos.lol"];
        const relays = [`wss://black.nostrcity.club`, `wss://eu.purplerelay.com`];
        let localStream;
        const peerAudios = {};
        const peerVideos = {};
        
        // DOMå…ƒç´ 
        const privateKeyInput = document.getElementById('privateKey');
        const publicKeyInput = document.getElementById('publicKey');
        const relayUrlInput = document.getElementById('relayUrl');
        const broadcastBtn = document.getElementById('broadcast');
        const subscribeTopicInput = document.getElementById('subscribeTopic');
        const subscribeBtn = document.getElementById('subscribe');
        const unsubscribeBtn = document.getElementById('unsubscribe');
        const receivedMessages = document.getElementById('receivedMessages');
        const localVideo = document.getElementById('localVideo');
		const remoteVideos = document.getElementById('remoteVideos');
        subscribeTopicInput.value = 'nostr_room'; // é è¨­æˆ¿é–“åç¨±
        let room = `zxc`; // é è¨­æˆ¿é–“åç¨±
        let present_time = 0;
        let peerConnection = null;
        const configuration = {
			iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
		};
        
        // åˆå§‹åŒ–
        function init() {
            //generateKeysBtn.addEventListener('click', generateKeys);
            subscribeBtn.addEventListener('click', startSubscription);
            unsubscribeBtn.addEventListener('click', stopSubscription);

            // å¾localStorageåŠ è¼‰å¯†é‘°
            //if (localStorage.getItem('nostrPrivateKey')) {
               // privateKeyInput.value = localStorage.getItem('nostrPrivateKey');
               // updatePublicKey();
           // }
        }

        // ç”Ÿæˆå¯†é‘°å°
        function generateKeys() {
            try {
                const sk = generateSecretKey();
                const nsec = nip19.nsecEncode(sk);
                privateKeyInput.value = nsec;
                localStorage.setItem('nostrPrivateKey', nsec);
                updatePublicKey();
            } catch (error) {
                console.error('ç”Ÿæˆå¯†é‘°éŒ¯èª¤:', error);
                alert('ç”Ÿæˆå¯†é‘°å¤±æ•—: ' + error.message);
            }
        }

        // æ›´æ–°å…¬é‘°é¡¯ç¤º,æˆ¿é–“åç¨±
        function updatePublicKey() {
            const nsec = privateKeyInput.value;
            if (!nsec.startsWith('nsec1')) return;

            try {
                privateKey = nip19.decode(nsec).data;
                publicKey = getPublicKey(privateKey);
                const npub = nip19.npubEncode(publicKey);
                publicKeyInput.value = npub;
                // æ›´æ–°æˆ¿é–“åç¨±
                room = 'nostr_room'+subscribeTopicInput.value.trim(); 
            } catch (error) {
                console.error('è§£æå¯†é‘°éŒ¯èª¤:', error);
            }
        }

        
        // ç™¼é€presenceåœ¨ç·šæ¶ˆæ¯
        async function _sendPresence() {
            if (!privateKey) {
                alert('è«‹å…ˆç”Ÿæˆæˆ–è¼¸å…¥ç§é‘°');
                return;
            }
            try {
                const msg = JSON.stringify({ type: `presence`, pubkey: publicKey, content: `Join: ${room}` })
                // å‰µå»ºäº‹ä»¶
                const event = {
                    kind: 25121,
                    created_at: present_time,
                    tags: [['t', room]], // ä¸»é¡Œæ¨™ç±¤
                    content: msg,
                    pubkey: publicKey
                };

                // ç°½åäº‹ä»¶
                const signedEvent = finalizeEvent(event, privateKey);
                await Promise.any(pool.publish(relays, signedEvent));

            } catch (e) {
                console.error(`âŒ ç™¼é€ä¿¡ä»¤å¤±æ•—: ${e}`)
            }
        }

        // é–‹å§‹è¨‚é–±
        async function startSubscription() {
            // è¨­å®šåŠ å…¥æ™‚é–“
            present_time = Math.floor(Date.now() / 1000);
            if (!room) {
                alert('è«‹è¼¸å…¥Room');
                return;
            }
            //Creates Key Pairs
            generateKeys();
            
            subscription = pool.subscribe(relays,
                {
                    kinds: [25121],
                    '#t': [room], // éæ¿¾ç‰¹å®šä¸»é¡Œ
                    since: Math.floor(Date.now() / 1000) - 10000,//
                },
                {
                    async onevent(event) {
                        try {
                            if (event.kind !== 25121) return; // ç¢ºä¿æ˜¯ä¸»é¡Œ
                            displayMessage(event);
                            _handleEvent(event);
                        } catch (error) {
                            console.error('è§£å¯†æ¶ˆæ¯éŒ¯èª¤:', error);
                            return;
                        }

                    }
                }
            );

            subscribeBtn.disabled = true;
            unsubscribeBtn.disabled = false;
            _sendPresence()
            //const presenceInterval = setInterval(() => _sendPresence(), 20000)// æ¯20ç§’ç™¼é€ä¸€æ¬¡åœ¨ç·šæ¶ˆæ¯
        }


        function _handlePeerPresence(event) {
            const remotePk = event.pubkey;
            if (!connections.has(remotePk)) {
                // åˆå§‹åŒ–æ–°çš„ WebRTC è¿æ¥
                _initConnection(event, remotePk)
            }
        }

        async function _initConnection(event,remotePk) {
            if (connections.has(remotePk)) {
                console.warn(`å·²å­˜åœ¨èˆ‡ ${remotePk} çš„é€£æ¥`);
                return;
            }
            try {
				localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
				localVideo.srcObject = localStream;
				peerConnection = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });
                connections.set(remotePk, peerConnection);
                //console.log(`connections set:`, connections);
				localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

                // è¨­ç½®é€šé“
                const dataChannel = peerConnection.createDataChannel('nostr-godot',
                    {
                        ordered: true, // ç¢ºä¿æ¶ˆæ¯æŒ‰é †åºåˆ°é”
                        maxRetransmits: 10 // è¨­ç½®æœ€å¤§é‡å‚³æ¬¡æ•¸
                    }
                );

                dataChannel.onopen = () => {
                    console.log(nip19.npubEncode(remotePk), `é€šé“å·²é€£æ¥`);
                };

                // åœ¨ _initConnection ä¸­æ·»åŠ å°æ–¹é€šé“ç›£è½
                peerConnection.ondatachannel = (event) => {
                    const remoteDataChannel = event.channel;
                    remoteDataChannel.onmessage = (event) => {
                        console.log(`æ”¶åˆ°ä¾†è‡ª ${nip19.npubEncode(remotePk)} çš„æ¶ˆæ¯:`, event.data);
                        _handleMessage({pubkey:nip19.npubEncode(remotePk), message:event.data}); // ä½¿ç”¨å·²çŸ¥çš„remotePk
                    };

                    // å­˜å‚¨å¯¹æ–¹çš„dataChannelï¼ˆå¦‚æœéœ€è¦ä¸»åŠ¨å‘é€ï¼‰
                    peerConnection.datachannel = dataChannel;
                };
                

                dataChannel.onclose = () => {
                    console.log(nip19.npubEncode(remotePk), `é€šé“å·²é—œé–‰`);
                };
                
                peerConnection.onicecandidate = event => {
					if (event.candidate) {
						_sendSignal(remotePk, { type: 'ice', candidate: event.candidate });
					}
				};

				peerConnection.ontrack = event => {
                    //remoteVideo.srcObject = event.streams[0];
                    let video = peerVideos[remotePk];
                    if (!video) {
                        video = document.createElement("video");
                        video.setAttribute("id", remotePk);
                        // iOS æ‰‹æ©Ÿä½¿ç”¨æ™‚ï¼Œå¿…é ˆå¢åŠ çš„å±¬æ€§
                        video.setAttribute("autoplay", "");
                        video.setAttribute("muted", "");
                        video.setAttribute("playsinline", "");
                        video.srcObject = event.streams[0];
                        peerVideos[remotePk] = video;
                        remoteVideos.appendChild(video);
                    }
                    console.log('âœ… é ç«¯è¦–è¨Šæµå·²æ¥æ”¶');
                };

				peerConnection.onconnectionstatechange = () => {
					console.log(`ğŸŒ é€£ç·šç‹€æ…‹: ${peerConnection.connectionState}`);
					if (peerConnection.connectionState === 'connected') {
						console.log('ğŸ‰ é€šè©±å·²é€£ç·šï¼');
                        broadcast(JSON.stringify({'message': 'å·²é€£ç·š'}));
					}
				};
			} catch (error) {
				console.log(`âŒ å•Ÿå‹• WebRTC å¤±æ•—: ${error.message}`);
				throw error; // Propagate error to stop the call process
			}
            // present_timeæ˜¯æœ¬æ©Ÿç¬¬ä¸€æ¬¡é€å‡ºpresenceçš„æ™‚é–“,å¾Œé¢åŠ å…¥çš„peerConnectionç•¶offer
            if (  present_time > event.created_at) {
                console.log('present_time',present_time,' event.created_at',event.created_at);
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                await _sendSignal(remotePk, { type: 'offer', sdp: offer.sdp });
            }
            _setupConnectionMonitoring(remotePk, peerConnection);

        }


        function _handleEvent(event) {
            if (event.pubkey === publicKey) return // å¿½ç•¥è‡ªå·±çš„äº‹ä»¶
            
            //remotePk = event.pubkey
            try {
                const data = JSON.parse(event.content)
                if (data.type === 'presence') {
                    _handlePeerPresence(event)
                    
                //ç¢ºå®šæ”¶åˆ° tags[1][1] æ˜¯çµ¦è‡ªå·±çš„ä¿¡ä»¤
                } else if (data.type === 'signal' && event.tags[1][0] === 'p' && event.tags[1][1] === publicKey) {
                    console.log('type:',data.type,` æ”¶åˆ°tags:`, event.tags, ` pk:`, publicKey);
                    _handleSignal(event, data.signal)
                }
            } catch (e) {
                console.error('Error parsing event content', e)
            }
        }

        function _handleSignal(event, signal) {
            //Sender pubkey
            const senderPk = event.pubkey;
            const connection = connections.get(senderPk);

            if (!connection) return;
            
            if (signal.type === 'offer') {
                console.log(`æ”¶åˆ°offer:`, signal);
                _handleOffer(senderPk, connection, signal);
            } else if (signal.type === 'answer') {
                console.log(`æ”¶åˆ°answer:`, signal);
                _handleAnswer(connection, senderPk, signal);
            console.log(`æ”¶åˆ°ICEå€™é€‰:`, signal);
            } else if (signal.type === 'ice') {
                _handleIce(connection, senderPk, signal);
            }
        }

       async function _handleOffer(remotePk, connection, { sdp }) {
            // ç¡®ä¿ä¹‹å‰æ²¡æœ‰è®¾ç½®è¿‡è¿œç¨‹æè¿°
            if (connection.remoteDescription ) {
                console.warn('Remote description already set')
                return
            }
            try {
                
                await connection.setRemoteDescription({ type: 'offer', sdp });
                const answer = await connection.createAnswer();
                await connection.setLocalDescription(answer);
                await _sendSignal(remotePk, { type: 'answer', sdp: answer.sdp });
            } catch (error) {
                console.error(`å¤„ç†offerå¤±è´¥:`, error);
            }
        }

        
        async function _handleAnswer(connection, pubkey, { sdp }) {
            const pc = connections.get(pubkey);
            if (!pc || pc.signalingState !== 'have-local-offer') return;
            await pc.setRemoteDescription({
                type: 'answer',
                sdp
            });
            await _flushIceCandidates(pc, pubkey);
        }

            // åœ¨è®¾ç½®è¿œç¨‹æè¿°ååˆ·æ–°ç¼“å†²çš„å€™é€‰
            async function _flushIceCandidates(connection, remotePk) {
                if (!iceCandidateBuffers.has(remotePk)) return;

                const candidates = iceCandidateBuffers.get(remotePk);
                while (candidates.length > 0) {
                    const candidate = candidates.shift();
                    try {
                        await connection.addIceCandidate(candidate);
                    } catch (error) {
                        console.error(`æ·»åŠ ç¼“å†²ICEå€™é€‰å¤±è´¥:`, error);
                    }
                }
                iceCandidateBuffers.delete(remotePk);
            }


        async function _handleIce(connection, remotePk, { candidate }) {
                // ç¼“å†²å€™é€‰ç›´åˆ°è¿œç¨‹æè¿°å°±ç»ª
                if (!connection.remoteDescription) {
                    if (!iceCandidateBuffers.has(remotePk)) {
                        iceCandidateBuffers.set(remotePk, []);
                    }
                    iceCandidateBuffers.get(remotePk).push(candidate);
                    return;
                }

                try {
                    await connection.addIceCandidate(candidate);
                } catch (error) {
                    console.error(`æ·»åŠ ICEå€™é€‰å¤±è´¥:`, error);
                }
            }

        async function _sendSignal(remotePk, signal) {
            try {
                // å‰µå»ºäº‹ä»¶
                const event = {
                    kind: 25121,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [
                        ['t', room],
                        ['p', remotePk] // å®šå‘åˆ°ç‰¹å®šå¯¹ç­‰èŠ‚ç‚¹
                    ],
                    content: JSON.stringify({
                        type: 'signal',
                        signal
                    }),
                    pubkey: publicKey//Sender pubkey
                };

                // ç°½åäº‹ä»¶
                const signedEvent = finalizeEvent(event, privateKey);
                await Promise.any(pool.publish(relays, signedEvent));

            } catch (e) {
                console.error(`âŒ ç™¼é€ä¿¡ä»¤å¤±æ•—: ${e}`)
            }

        }

        function _setupConnectionMonitoring(remotePk, pc) {
                pc.onconnectionstatechange = () => {
                    console.log(`${nip19.npubEncode(remotePk)} é€£æ¥ç‹€æ…‹: ${pc.connectionState}`);

                    if (pc.connectionState === 'failed' ||
                        pc.connectionState === 'disconnected') {
                        _cleanupConnection(remotePk);
                    }
                };
            }

            function _cleanupConnection(remotePk) {
                const pc = connections.get(remotePk);
                if (!pc) return;

                // å…³é—­æ•°æ®é€šé“å’Œè¿æ¥
                if (pc.datachannel) pc.datachannel.close();
                if (pc.remoteDataChannel) pc.remoteDataChannel.close();
                pc.close();

                // æ¸…ç†èµ„æº
                connections.delete(remotePk);
                iceCandidateBuffers.delete(remotePk);

                // ç§»é™¤è§†é¢‘å…ƒç´ 
                const video = peerVideos[remotePk];
                if (video && video.parentNode) {
                    video.parentNode.removeChild(video);
                    delete peerVideos[remotePk];
                }
            }
        function getPeerConnectionState(connection) {
            return {
                signalingState: connection.signalingState,
                iceGatheringState: connection.iceGatheringState,
                iceConnectionState: connection.iceConnectionState,
                connectionState: connection.connectionState
            }
        }

        function disconnect() {
            clearInterval(presenceInterval)
            for (const relay of relayConnections) {
                relay.close()
            }
            relayConnections = []
        }

        // é¡¯ç¤ºæ¥æ”¶åˆ°çš„æ¶ˆæ¯
        function displayMessage(event) {
            const topicTag = event.tags.find(tag => tag[0] === 't');
            const topic = topicTag ? topicTag[1] : 'ç„¡ä¸»é¡Œ';
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            messageDiv.innerHTML = `
                <small>ä¸»é¡Œ: ${topic}</small><br>
                ${event.content}<br>
                                
                <small>ä¾†è‡ª: ${event.pubkey.substring(0, 10)}... | 
                    ${event.created_at}</small>`
                ;

            receivedMessages.prepend(messageDiv);
        }

        // åœæ­¢è¨‚é–±
        function stopSubscription() {
            if (subscription) {
                subscription.close(); // æˆ– subscription.unsub();
                subscription = null;
            }

            subscribeBtn.disabled = false;
            unsubscribeBtn.disabled = true;
            console.log('å·²åœæ­¢è¨‚é–±');
        }

        // å•Ÿå‹•æ‡‰ç”¨
        init();
       
        
        broadcastBtn.addEventListener('click', () => {
            if (connections.size === 0) {
                alert('æ²’æœ‰å¯ç”¨çš„é€£æ¥');
                return;
            }
            const data =  {'message': 'é€™æ˜¯ä¸€å€‹å»£æ’­æ¶ˆæ¯'}; // é€™æ˜¯ä¸€å€‹å»£æ’­æ¶ˆæ¯ ;
            broadcast(JSON.stringify(data));
            console.log('é»æ“Šå»£æ’­æŒ‰éˆ•');
          
        });

        function broadcast(data) {
                connections.forEach((pc, pubkey) => {
                    if (pc.datachannel?.readyState === 'open') {
                        console.log(pc.datachannel?.readyState, 'ç™¼é€æ•¸æ“šåˆ°', nip19.npubEncode(pubkey));
                        pc.datachannel.send(data);
                    }
                });
            }

        function _handleMessage(data) {
            try {
               console.log(`æ”¶åˆ°è§£æå¾Œçš„æ¶ˆæ¯:`, data);
                // å˜—è©¦è§£æ JSON æ•¸æ“š
                if (data !== null && typeof data === 'object') {
                    const msg = data;
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'message';
                    messageDiv.innerHTML = `
                        <small>æ”¶åˆ°${msg.pubkey.substring(0, 10)}çš„æ¶ˆæ¯:${msg.message}</small>`;
                    receivedMessages.prepend(messageDiv);
                }
            } catch (error) {
                console.error('è§£ææ¶ˆæ¯å¤±æ•—:', error);
                return;
            }
        };

    </script>
 
    
    
</body>

</html>