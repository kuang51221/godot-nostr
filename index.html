<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <title>Nostr</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: Arial, Helvetica, sans-serif;
        }

        #canvas {
            /* The Godot canvas itself */
            width: 100%;
            height: 100%;
            display: block;
            /* Remove extra space below canvas */
        }

        /* Style the header */

        header {
            background-color: #666;
            padding: 1px;
            text-align: center;
            font-size: 10px;
            color: white;
        }

        /* Create two columns/boxes that floats next to each other */
        nav {
            float: left;
            width: 80%;
            /* height: 300px;  only for demonstration, should be removed */
            background: #ccc;
            padding: 5px;
            overflow-y: auto;
        }

        /* Style the list inside the menu */
        nav ul {
            list-style-type: none;
            padding: 0;
        }

        article {
            float: left;
            padding: 5px;
            width: 20%;
            background-color: #f1f1f1;
            /*height: 300px;  only for demonstration, should be removed */
            overflow-y: scroll;
        }

        /* Clear floats after the columns */
        section::after {
            content: "";
            display: table;
            clear: both;
        }

        /* Style the footer */
        footer {
            background-color: #777;
            padding: 10px;
            text-align: center;
            color: white;
        }

        /* Responsive layout - makes the two columns/boxes stack on top of each other instead of next to each other, on small screens */
        @media (max-width: 600px) {

            nav,
            article {
                width: 100%;
                height: auto;
            }
        }

        #video-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3px;
        }

        video {
            width: 95%;
            border-radius: 1px;
            padding: 3px;
            background: rgba(255, 255, 255, 0);
        }
    </style>
</head>


<body>

    <header>
        <h3>Godot-Nostr</h3>
    </header>
    <section>
        <nav>
            <canvas id="canvas" width="460" height="360" style="border:1px solid #000000;">
            </canvas>
        </nav>
        <article style="overflow-y: scroll;">

            <div class="video" style="border-radius: 5px;">
                <video id="localVideo" autoplay muted
                    style="width: 100%;  background-color: rgb(4, 36, 4); margin-top: 1px;"></video>
            </div>
            <div class="video" style="border-radius: 5px;">
                <video id="remoteVideo" autoplay
                    style="width: 100%; background-color: rgb(4, 36, 4); margin-top: 1px;"></video>
            </div>
        </article>
    </section>
    <footer>
        <div class="section">
            <h2>1. å¸³æˆ¶è¨­ç½®</h2>
            <button id="generateKeys">ç”Ÿæˆæ–°å¯†é‘°</button>
            <div>
                <label for="privateKey">ç§é‘° (nsec):</label>
                <input type="text" id="privateKey" placeholder="nsec1...">
            </div>
            <div>
                <label for="publicKey">å…¬é‘° (npub):</label>
                <input type="text" id="publicKey" readonly>
            </div>

        </div>

        <div class="section">
            <h2>2. ç™¼ä½ˆä¸»é¡Œæ¶ˆæ¯</h2>
            <div>
                <label for="topic">ä¸»é¡Œ:</label>
                <input type="text" id="topic" placeholder="ä¾‹å¦‚: news, bitcoin, nostr">
            </div>
            <div>
                <label for="messageContent">æ¶ˆæ¯å…§å®¹:</label>
                <textarea id="messageContent" rows="3"></textarea>
            </div>
            <button id="publish">ç™¼ä½ˆæ¶ˆæ¯</button>
            <div id="publishStatus"></div>
        </div>
        <div class="section">
            <h2>3. è¨‚é–±ä¸»é¡Œæ¶ˆæ¯</h2>
            <div>
                <label for="subscribeTopic">Room:</label>
                <input type="text" id="subscribeTopic" placeholder="è¼¸å…¥Room">
            </div>
            <button id="subscribe">é–‹å§‹Roomè¨‚é–±</button>
            <button id="unsubscribe" disabled>åœæ­¢è¨‚é–±</button>
            <h3>æ”¶åˆ°çš„æ¶ˆæ¯:</h3>
            <div id="receivedMessages"></div>
        </div>
    </footer>


    <script type="module">
        import * as nostrTools from "https://esm.sh/nostr-tools@2.15.0";

        const {
            generateSecretKey, getPublicKey, finalizeEvent, nip19, SimplePool, nip04
        } = nostrTools;
        // å…¨å±€è®Šé‡
        let room = 'nostr_14_room'
        let privateKey = '';
        let publicKey = '';
        let remotePk = '';
        let subscription = null;
        let pool = new SimplePool();
        let connections = new Map()
        let candidateBuffers = new Map();
        let relayConnections = []
        const relays = ["wss://relay.damus.io", "wss://relay.snort.social", "wss://nos.lol"];
        let localStream;
        // DOMå…ƒç´ 
        const generateKeysBtn = document.getElementById('generateKeys');
        const privateKeyInput = document.getElementById('privateKey');
        const publicKeyInput = document.getElementById('publicKey');
        const relayUrlInput = document.getElementById('relayUrl');

        const topicInput = document.getElementById('topic');
        const messageContentInput = document.getElementById('messageContent');
        const publishBtn = document.getElementById('publish');
        const publishStatus = document.getElementById('publishStatus');

        const subscribeTopicInput = document.getElementById('subscribeTopic');
        const subscribeBtn = document.getElementById('subscribe');
        const unsubscribeBtn = document.getElementById('unsubscribe');
        const receivedMessages = document.getElementById('receivedMessages');
        const localVideo = document.getElementById('localVideo');
		const remoteVideo = document.getElementById('remoteVideo');


        topicInput.value = room
        subscribeTopicInput.value = room
        messageContentInput.value = `rtc test`
        // åˆå§‹åŒ–
        function init() {
            generateKeysBtn.addEventListener('click', generateKeys);
            publishBtn.addEventListener('click', publishMessage);
            subscribeBtn.addEventListener('click', startSubscription);
            unsubscribeBtn.addEventListener('click', stopSubscription);

            // å¾localStorageåŠ è¼‰å¯†é‘°
            if (localStorage.getItem('nostrPrivateKey')) {
                privateKeyInput.value = localStorage.getItem('nostrPrivateKey');
                updatePublicKey();
            }
        }

        // ç”Ÿæˆå¯†é‘°å°
        function generateKeys() {
            try {
                const sk = generateSecretKey();
                const nsec = nip19.nsecEncode(sk);
                privateKeyInput.value = nsec;
                localStorage.setItem('nostrPrivateKey', nsec);
                updatePublicKey();
            } catch (error) {
                console.error('ç”Ÿæˆå¯†é‘°éŒ¯èª¤:', error);
                alert('ç”Ÿæˆå¯†é‘°å¤±æ•—: ' + error.message);
            }
        }

        // æ›´æ–°å…¬é‘°é¡¯ç¤º
        function updatePublicKey() {
            const nsec = privateKeyInput.value;
            if (!nsec.startsWith('nsec1')) return;

            try {
                privateKey = nip19.decode(nsec).data;
                publicKey = getPublicKey(privateKey);
                const npub = nip19.npubEncode(publicKey);
                publicKeyInput.value = npub;
            } catch (error) {
                console.error('è§£æå¯†é‘°éŒ¯èª¤:', error);
            }
        }

        // ç™¼ä½ˆæ¶ˆæ¯
        async function publishMessage() {
            if (!privateKey) {
                alert('è«‹å…ˆç”Ÿæˆæˆ–è¼¸å…¥ç§é‘°');
                return;
            }

            const topic = topicInput.value.trim();
            const content = messageContentInput.value.trim();

            if (!topic || !content) {
                alert('è«‹å¡«å¯«ä¸»é¡Œå’Œå…§å®¹');
                return;
            }
            try {
                const msg = JSON.stringify({ "type": `presence`, "pubkey": publicKey, "content": content })
                // å‰µå»ºäº‹ä»¶
                const event = {
                    kind: 25122,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [['t', topic]], // ä¸»é¡Œæ¨™ç±¤
                    content: msg,
                    pubkey: publicKey
                };

                // ç°½åäº‹ä»¶
                const signedEvent = finalizeEvent(event, privateKey);
                await Promise.any(pool.publish(relays, signedEvent));

            } catch (e) {
                console.error(`âŒ ç™¼é€ä¿¡ä»¤å¤±æ•—: ${e}`)
            }
        }
        // ç™¼é€presenceåœ¨ç·šæ¶ˆæ¯
        async function _sendPresence() {
            if (!privateKey) {
                alert('è«‹å…ˆç”Ÿæˆæˆ–è¼¸å…¥ç§é‘°');
                return;
            }

            const topic = topicInput.value.trim();
            const content = messageContentInput.value.trim();

            if (!topic || !content) {
                alert('è«‹å¡«å¯«ä¸»é¡Œå’Œå…§å®¹');
                return;
            }
            try {
                const msg = JSON.stringify({ "type": `presence`, "pubkey": publicKey, "content": content })
                // å‰µå»ºäº‹ä»¶
                const event = {
                    kind: 25122,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [['t', topic]], // ä¸»é¡Œæ¨™ç±¤
                    content: msg,
                    pubkey: publicKey
                };

                // ç°½åäº‹ä»¶
                const signedEvent = finalizeEvent(event, privateKey);
                await Promise.any(pool.publish(relays, signedEvent));

            } catch (e) {
                console.error(`âŒ ç™¼é€ä¿¡ä»¤å¤±æ•—: ${e}`)
            }
        }

        // é–‹å§‹è¨‚é–±
        async function startSubscription() {
            const topic = subscribeTopicInput.value.trim();
            if (!topic) {
                alert('è«‹è¼¸å…¥è¦è¨‚é–±çš„Room');
                return;
            }
            subscription = pool.subscribe(relays,
                {
                    kinds: [25122],
                    '#t': [topic], // éæ¿¾ç‰¹å®šä¸»é¡Œ
                    since: Math.floor(Date.now() / 1000)  // æœ€è¿‘1åˆ†é˜çš„æ¶ˆæ¯
                },
                {
                    async onevent(event) {
                        try {
                            if (event.kind !== 25122) return; // ç¢ºä¿æ˜¯ä¸»é¡Œ
                            displayMessage(event);
                            _handleEvent(event);
                       
                        } catch (error) {
                            console.error('è§£å¯†æ¶ˆæ¯éŒ¯èª¤:', error);
                            return;
                        }

                    }
                }
            );

            subscribeBtn.disabled = true;
            unsubscribeBtn.disabled = false;
            _sendPresence()
            const presenceInterval = setInterval(() => publishMessage(), 30000)
            //console.log(`å·²è¨‚é–±ä¸»é¡Œ: ${topic}`);
        }

        function _handleEvent(event) {
            if (event.pubkey === publicKey) return // å¿½ç•¥è‡ªå·±çš„äº‹ä»¶
            remotePk = event.pubkey
            try {
                const data = JSON.parse(event.content)
                if (data.type === 'presence') {
                    _handlePeerPresence(remotePk)
                } else if (data.type === 'signal') {
                    _handleSignal(remotePk, data.signal)
                }
            } catch (e) {
                console.error('Error parsing event content', e)
            }
        }

        function _handlePeerPresence(remotePk) {
            if (!connections.has(remotePk)) {
                // åˆå§‹åŒ–æ–°çš„ WebRTC è¿æ¥
                _initConnection(remotePk)
            }
        }

        async function _initConnection(remotePk) {
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
			localVideo.srcObject = localStream;
            const connection = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            })
            //è¨˜éŒ„å·²å»ºç«‹çš„é€£æ¥
            connections.set(remotePk, connection)
            localStream.getTracks().forEach(track => connection.addTrack(track, localStream));

            // è®¾ç½®æ•°æ®é€šé“
            const dataChannel = connection.createDataChannel('trystero')

            // å¤„ç† ICE å€™é€‰
            connection.onicecandidate = ({ candidate }) => {
                if (candidate) {
                    _sendSignal(remotePk, {
                        type: 'ice',
                        candidate
                    })
                }
            }
            connection.ontrack = event => {
					remoteVideo.srcObject = event.streams[0];
					log('âœ… é ç«¯è¦–è¨Šæµå·²æ¥æ”¶');
				};
            connection.onconnectionstatechange = () => {
					console.log(`ğŸŒ é€£ç·šç‹€æ…‹: ${connection.connectionState}`);
				};

            // åˆ›å»ºoffer
            const offer = await connection.createOffer()
            await connection.setLocalDescription(offer)

            _sendSignal(remotePk, {
                type: 'offer',
                sdp: offer.sdp
            })
        }

        function _handleSignal(remotePk, signal) {
            const connection = connections.get(remotePk);
            if (!connection) return;

            // ç¡®ä¿å…ˆå¤„ç†offer/answerï¼Œå†å¤„ç†ICEå€™é€‰
            if (signal.type === 'offer') {
                _handleOffer(remotePk, connection, signal);
            } else if (signal.type === 'answer') {
                _handleAnswer(connection, remotePk, signal);
            } else if (signal.type === 'ice') {
                _handleIce(connection, remotePk, signal);
            }
        }

        async function _handleOffer(remotePk, connection, { sdp }) {
            // ç¡®ä¿ä¹‹å‰æ²¡æœ‰è®¾ç½®è¿‡è¿œç¨‹æè¿°
            if (connection.remoteDescription) {
                console.warn('Remote description already set')
                return
            }
            await connection.setRemoteDescription({
                type: 'offer',
                sdp
            })

            const answer = await connection.createAnswer()
            await connection.setLocalDescription(answer)

            _sendSignal(remotePk, {
                type: 'answer',
                sdp: answer.sdp
            })
        }


        async function _flushIceCandidates(connection, pubkey) {
            if (!this.candidateBuffers.has(pubkey)) return;

            const candidates = this.candidateBuffers.get(pubkey);
            while (candidates.length > 0) {
                const candidate = candidates.shift();
                try {
                    await connection.addIceCandidate(candidate);
                } catch (e) {
                    console.error('Error adding buffered ICE candidate', e);
                }
            }
            this.candidateBuffers.delete(pubkey);
        }

        async function _handleAnswer(connection, pubkey, { sdp }) {
            await connection.setRemoteDescription({
                type: 'answer',
                sdp
            });
            await this._flushIceCandidates(connection, pubkey);
        }



        async function _handleIce(connection, pubkey, { candidate }) {
            // å¦‚æœè¿œç¨‹æè¿°å°šæœªè®¾ç½®ï¼Œç¼“å†²å€™é€‰
            if (!connection.remoteDescription) {
                if (!candidateBuffers.has(pubkey)) {
                    candidateBuffers.set(pubkey, []);
                }
                candidateBuffers.get(pubkey).push(candidate);
                return;
            }

            // å¦åˆ™ç›´æ¥æ·»åŠ å€™é€‰
            try {
                await connection.addIceCandidate(candidate);
            } catch (e) {
                console.error('Error adding ICE candidate', e);
            }
        }

        async function _sendSignal(pubkey, signal) {
            try {
                // å‰µå»ºäº‹ä»¶
                const event = {
                    kind: 25122,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [
                        ['t', room],
                        ['p', pubkey] // å®šå‘åˆ°ç‰¹å®šå¯¹ç­‰èŠ‚ç‚¹
                    ],
                    content: JSON.stringify({
                        type: 'signal',
                        signal
                    }),
                    pubkey: publicKey
                };

                // ç°½åäº‹ä»¶
                const signedEvent = finalizeEvent(event, privateKey);
                await Promise.any(pool.publish(relays, signedEvent));

            } catch (e) {
                console.error(`âŒ ç™¼é€ä¿¡ä»¤å¤±æ•—: ${e}`)
            }

        }

        function getPeerConnectionState(connection) {
            return {
                signalingState: connection.signalingState,
                iceGatheringState: connection.iceGatheringState,
                iceConnectionState: connection.iceConnectionState,
                connectionState: connection.connectionState
            }
        }

        function disconnect() {
            clearInterval(presenceInterval)
            for (const relay of relayConnections) {
                relay.close()
            }
            relayConnections = []
        }

        // é¡¯ç¤ºæ¥æ”¶åˆ°çš„æ¶ˆæ¯
        function displayMessage(event) {
            const topicTag = event.tags.find(tag => tag[0] === 't');
            const topic = topicTag ? topicTag[1] : 'ç„¡ä¸»é¡Œ';
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            messageDiv.innerHTML = `
                <strong>ä¸»é¡Œ: ${topic}</strong><br>
                ${event.content}<br>
                                
                <small>ä¾†è‡ª: ${event.pubkey.substring(0, 10)}... | 
                    ${new Date(event.created_at * 1000).toLocaleString()}</small>`
                ;

            receivedMessages.prepend(messageDiv);
        }

        // åœæ­¢è¨‚é–±
        function stopSubscription() {
            if (subscription) {
                subscription.close(); // æˆ– subscription.unsub();
                subscription = null;
            }

            subscribeBtn.disabled = false;
            unsubscribeBtn.disabled = true;
            console.log('å·²åœæ­¢è¨‚é–±');
        }

        // å•Ÿå‹•æ‡‰ç”¨
        init();


        var toGodot = null;

  window.JSGD = {
// ç”Ÿæˆé‡‘é‘°
	getVal: function() {
		return ("value" in window) ? value : "æœªè¨­å®š";
	},
	gdcb: function(gdCbFunc) {
		if (typeof gdCbFunc === "function") {
      toGodot = gdCbFunc;
      // ç«‹å³æ¸¬è©¦å›èª¿
      gdCbFunc("JavaScript å›èª¿å‡½æ•¸å·²è¨­ç½®");
      log("Godot callback function ready to use");
    } else {
      log("Godot callback function must be a function");
    }
	}
};


    </script>

    
    <!--  Godot Godot Bridge -->
    <script src="index.js"></script>
    <script>
        const GODOT_THREADS_ENABLED = false;
        var engine = new Engine({"args":[],"canvasResizePolicy":2,"ensureCrossOriginIsolationHeaders":true,"executable":"index","experimentalVK":false,"fileSizes":{"index.pck":5246080,"index.wasm":43016933},"focusCanvas":true,"gdextensionLibs":[]});
        engine.startGame({
            /* optional override configuration, eg. */
            //args:[],
            //unloadAfterInit: false,
            focusCanvas: true,
            gdextensionLibs: [],
            ensureCrossOriginIsolationHeaders: true,
            canvasResizePolicy: 0,
        });

    </script>
</body>

</html>
